'use strict';

var should = require('chai').should(),
  amqp = require('amqplib'),
  q = require('q'),
  sinon = require('sinon');

var rpcPublisherFactory = require('../lib/rpc-publisher-factory');

describe('RPC Client', function () {

  afterEach(function(done) {
    if(amqp.connect.restore) {
      amqp.connect.restore();
    }
    done();
  });

  it('should handle connection failure', function(done) {

    sinon.stub(amqp, 'connect', function () {
      var deferred = q.defer();
      deferred.reject(new Error('Stubbed amqp.connect()'));
      return deferred.promise;
    });

    var publisher = rpcPublisherFactory.create();

    publisher.publish('publish a message')
      .catch(function publishError(err) {
        should.exist.err;
        err.status.should.equal(503);
        err.message.should.equal('Service Unavailable');
      })
      .then(done, done);

  });

  it('should send a message and receive a reply', function (done) {

    // The correlation ID generated by the publish method, sent to the consumer then returned by the consumer so the publisher can verify with it
    // Need to store it during the test so the test can verify with it
    var correlationId;

    // The expected sent and reply strings
    var messageSent = 'Publish a Test Message';
    var messageReply = 'Publish a Test Message-OK';

    // The reply-to queue the publisher will send to the consumer
    var uniqueAmqpPrivateReplyQueue = 'a45sdf6-7r98w-adf79s-65io4u';

    var assertQueueThenStub = {
      then: function (callback) {
        return callback();
      }
    };

    var channelStub = {
      assertQueue: function () {
        return {
          then: function (callback) {
            callback({queue: uniqueAmqpPrivateReplyQueue});
            return assertQueueThenStub;
          }
        };
      },

      consume: function (queue, callback, options) {
        queue.should.equal(uniqueAmqpPrivateReplyQueue);
        callback.name.should.equal('maybeAnswer');
        options.noAck.should.be.true;

        // This is the reply from the consumer
        // In this example we'll make it so the consumer simply appends 'OK' to the sent message and returns it
        // Use setImmediate so that the callback is run on the next tick of the event loop.
        setImmediate(function() {
          callback({
            content: new Buffer(messageSent + '-OK'),
            properties: {
              correlationId: correlationId
            }
          });
        });

      },

      sendToQueue: function (replyTo, content, options) {
        // Store the correlationID, used in the reply maybeAnswer function
        correlationId = options.correlationId;

        replyTo.should.equal('node_rpc_queue');
        content.toString().should.equal(messageSent);
        options.replyTo.should.equal(uniqueAmqpPrivateReplyQueue);
      }

    };

    var createChannelStub = {
      createChannel: function () {
        return {
          then: function (createChannelSuccess) {
            return createChannelSuccess(channelStub);
          }
        };
      },
      close: function () {
        // TODO add spy here
      }
    };

    var connectStub = {
      then: function (getConnectionSuccess) {
        return getConnectionSuccess(createChannelStub);
      }
    };

    sinon.stub(amqp, 'connect').returns(connectStub);

    var publisher = rpcPublisherFactory.create({
      standalone: true
    });

    publisher.publish(messageSent)
      .then(function publishSuccess(res) {
        should.exist.res;
        res.should.equal(messageReply);
      })
      .then(done, done);

  });

});
